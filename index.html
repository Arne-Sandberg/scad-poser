<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SCAD editor created with ANTLR4</title>
  <link rel="stylesheet" type="text/css" href="css/velvet.css">

  <script src="require.js"></script>
  <script src="js/velvet.js"></script>
  <script src="js/StreamSaver.js"></script>
  <script src="js/cytoscape.min.js"></script>
  <script src="https://unpkg.com/dagre@0.7.4/dist/dagre.js"></script>
  <script src="js/lib/cytoscape-dagre.js"></script>
<script type="application/javascript">
var antlr4 = require('antlr4/index');
var ATNState = require('antlr4/atn/ATNState').ATNState;
  
  function recurseATN(rule, cy, startState, transition, inBlock){
    var edgeId=cy.edges().length+1;
    if(edgeId>=80)return;
    switch(transition.target.stateType){
      case ATNState.RULE_START:
        if(inBlock){
          var id="";
          for(var innerIndex in transition.target.stopState.transitions){
            if(transition.target.stopState.transitions[innerIndex].target.stateType===ATNState.BLOCK_END &&
                    transition.target.stopState.transitions[innerIndex].target.ruleIndex===rule){
              id=transition.target.stopState.transitions[innerIndex].target.stateNumber.toString();
              break;
            }
          }
          if(id.length>0){
            if(cy.getElementById(id).length===0)
            cy.add({
                group: "nodes",
                data: { id: id, name: id, faveColor: "blue", faveShape: 'ellipse' }
            });
             cy.add({
                group: "edges",
                data: { id: "e"+edgeId.toString(), source: startState.stateNumber.toString(), target: id, name: velvet.parser.ruleNames[transition.target.ruleIndex] }
            });
          }
          else{
          console.log(startState.stateNumber+" else"+transition.target.stateNumber);
          console.log("else trstartState");
          console.log(startState);
          if(transition.followState.stateType===ATNState.BASIC &&
                    transition.followState.ruleIndex===rule){
            if(cy.getElementById(transition.followState.stateNumber.toString()).length===0)
            cy.add({
                group: "nodes",
                data: { id: transition.followState.stateNumber.toString(), name: transition.followState.stateNumber.toString(), faveColor: "blue", faveShape: 'ellipse' }
            });
             cy.add({
                group: "edges",
                data: { id: "e"+edgeId.toString(), source: startState.stateNumber.toString(), target: transition.followState.stateNumber.toString(), name: velvet.parser.ruleNames[transition.ruleIndex] }
            });
            recurseATN(rule, cy, transition.followState, transition.followState.transitions[0], inBlock);
          }
          else{
            /*if(cy.getElementById(transition.target.stateNumber.toString()).length===0)
            cy.add({
                group: "nodes",
                data: { id: transition.target.stateNumber.toString(), name: transition.target.stateNumber.toString(), faveColor: "blue", faveShape: 'ellipse' }
            });
            cy.add({
                group: "edges",
                data: { id: "e"+edgeId.toString(), source: startState.stateNumber.toString(), target: transition.target.stateNumber.toString(), name: velvet.parser.literalNames[transition.label_] }
            });
            console.log("transition.target");
            //console.log(transition.target);
            recurseATN(rule, cy, transition.target, transition.target.transitions[0], false);
            */
          }
          }
        }
        else{
          if(cy.getElementById(transition.target.stateNumber.toString()).length===0)
          cy.add({
              group: "nodes",
              data: { id: transition.target.stateNumber.toString(), name: transition.target.stateNumber.toString(), faveColor: "blue", faveShape: 'ellipse' }
          });
          cy.add({
              group: "edges",
              data: { id: "e"+edgeId.toString(), source: startState.stateNumber.toString(), target: transition.target.stateNumber.toString(), name: velvet.parser.literalNames[transition.label_] }
          });
          console.log("transition.target");
          console.log(transition.target);
          recurseATN(rule, cy, transition.target, transition.target.transitions[0], false);
          
        }
        break;
        case ATNState.STAR_LOOP_BACK:
        case ATNState.PLUS_LOOP_BACK:
          console.log(startState.stateType+" LOOP_BACK "+transition.target.stateType);
        if(cy.getElementById(transition.target.stateNumber.toString()).length===0)
        cy.add({
            group: "nodes",
            data: { id: transition.target.stateNumber.toString(), name: transition.target.stateNumber.toString(), faveColor: "blue", faveShape: 'ellipse' }
        });
        cy.add({
            group: "edges",
            data: { id: "e"+edgeId.toString(), source: startState.stateNumber.toString(), target: transition.target.stateNumber.toString(), name: (transition.isEpsilon) ? "ε": velvet.parser.literalNames[transition.label_] }
        });
        edgeId++;
        if(cy.getElementById(transition.target.transitions[0].target.stateNumber.toString()).length===0)
        cy.add({
            group: "nodes",
            data: { id: transition.target.transitions[0].target.stateNumber.toString(), name: transition.target.transitions[0].target.stateNumber.toString(), faveColor: "blue", faveShape: 'ellipse' }
        });
        cy.add({
            group: "edges",
            data: { id: "e"+edgeId.toString(), source: transition.target.stateNumber.toString(), target: transition.target.transitions[0].target.stateNumber.toString(), name: (transition.target.transitions[0].isEpsilon) ? "ε": velvet.parser.literalNames[transition.target.transitions[0].label_] }
        });
          break;
        case ATNState.RULE_STOP:
        if(cy.getElementById(transition.target.stateNumber.toString()).length===0)
        cy.add({
            group: "nodes",
            data: { id: transition.target.stateNumber.toString(), name: transition.target.stateNumber.toString(), faveColor: "blue", faveShape: 'ellipse' }
        });
        cy.add({
            group: "edges",
            data: { id: "e"+edgeId.toString(), source: startState.stateNumber.toString(), target: transition.target.stateNumber.toString(), name: (transition.isEpsilon) ? "ε": velvet.parser.literalNames[transition.label_] }
        });
        break;
      case ATNState.PLUS_BLOCK_START:
      case ATNState.STAR_BLOCK_START:
        if(cy.getElementById(transition.target.stateNumber.toString()).length===0)
        cy.add({
            group: "nodes",
            data: { id: transition.target.stateNumber.toString(), name: transition.target.stateNumber.toString(), faveColor: "blue", faveShape: 'rectangle' }
        });
        cy.add({
            group: "edges",
            data: { id: "e"+edgeId.toString(), source: startState.stateNumber.toString(), target: transition.target.stateNumber.toString(), name: velvet.parser.literalNames[transition.label_] }
        });
        console.log(transition.target.stateType+" BLOCK_START "+transition.target.transitions.length);
       for(var outterIndex in transition.target.transitions){
          recurseATN(rule, cy, transition.target, transition.target.transitions[outterIndex], true);
       }
        break;
      case ATNState.STAR_LOOP_ENTRY:
        if(cy.getElementById(transition.target.stateNumber.toString()).length===0)
        cy.add({
            group: "nodes",
            data: { id: transition.target.stateNumber.toString(), name: transition.target.stateNumber.toString(), faveColor: "blue", faveShape: 'rectangle' }
        });
        cy.add({
            group: "edges",
            data: { id: "e"+edgeId.toString(), source: startState.stateNumber.toString(), target: transition.target.stateNumber.toString(), name: velvet.parser.literalNames[transition.label_] }
        });
        console.log("STAR_LOOP_ENTRY "+transition.target.transitions.length);
       for(var outterIndex in transition.target.transitions){
          recurseATN(rule, cy, transition.target, transition.target.transitions[outterIndex], false);
       }
        break;
      default:
        if(cy.getElementById(transition.target.stateNumber.toString()).length===0)
        cy.add({
            group: "nodes",
            data: { id: transition.target.stateNumber.toString(), name: transition.target.stateNumber.toString(), faveColor: "blue", faveShape: 'ellipse' }
        });
        cy.add({
            group: "edges",
            data: { id: "e"+edgeId.toString(), source: startState.stateNumber.toString(), target: transition.target.stateNumber.toString(), name: (transition.isEpsilon) ? "ε": velvet.parser.literalNames[transition.label_] }
        });
        recurseATN(rule, cy, transition.target, transition.target.transitions[0], inBlock);
      break;
    }
  }
  
  function viewStylish(e, tokens, lexer, parser, tree){
    var canvas = document.getElementById('canvasEditor');
    var lines=tokens.tokens[0].source[1].strdata.split("\n");
    canvas.height=100+lines.length*16;
    velvet = new pmc.Velvet(canvas, tokens, lexer, parser, tree);
    velvet.addKeyListener((event) => {
      console.log(event.key);
      const fileStream = streamSaver.createWriteStream('filename.scad')
      const writer = fileStream.getWriter()
      const encoder = new TextEncoder
      let uint8array = encoder.encode(velvet.text)
      
      writer.write(uint8array)
      writer.close()
    });

    //autocomplete(document.getElementById("g4Input"), velvet.autoList);
    /*Svar xhr = new XMLHttpRequest(); 
    xhr.open('GET', "/scad/SCADLexer.tokens", true); 
    //xhr.responseType = "blob";
    xhr.onload = function() {
      if (xhr.status >= 200 && xhr.status < 400){
        // Success!
        velvet.populateAvailableTokens(xhr.responseText);
      } else {
        // We reached our target server, but it returned an error

      }
    };
    xhr.send(null);*/
        var atnGraph = document.createElement('div');
        //var atnGraph = document.getElementById('graph');
        atnGraph.id = "graph";
        atnGraph.style.width = '1200px';
        atnGraph.style.height =  '1500px';
        atnGraph.tabIndex = '3';
        atnGraph.style.backgroundColor = '#0FFFF';
        //atnGraph.style.color = '#000';
        //atnGraph.style.zIndex = '2';
        //atnGraph.style.animation = 'blinker 1s linear infinite';
        atnGraph.style.left = '10px';
        atnGraph.style.top = '8px';
        //atnGraph.style.marginTop ='200px';
        //atnGraph.style.marginTop = (-(10+velvet.rows*18/2))+'px';
        atnGraph.style.borderColor = "blue";
        var content = document.createTextNode("<YOUR_CONTENT>");
//atnGraph.appendChild(content);
    canvas.parentElement.appendChild(atnGraph);
    var cy = cytoscape({
      container: atnGraph // container to render in
      ,
          style: cytoscape.stylesheet()
    .selector('node')
      .css({
          'width' : '30',
          'height' : '30',
          'shape': 'data(faveShape)',
        'content': 'data(name)',
        'line-color': 'data(faveColor)'
      })
    .selector('edge')
      .css({
        'content': 'data(name)',
        'width': 2,
        'line-color': '#ddd'
      })
    .selector('.highlighted')
      .css({
        'background-color': '#61bffc',
        'line-color': '#61bffc',
        'target-arrow-color': '#61bffc',
        'transition-property': 'background-color, line-color, target-arrow-color',
        'transition-duration': '0.5s'
      }),
          hideLabelsOnViewport: false,
          ready: function(){ console.log('ready') }

    });
    var rule=99;
              var startState=parser._interp.atn.ruleToStartState[rule];
              console.log(startState);
              console.log(startState.stateNumber.toString());
                    var shape=  'ellipse';
              cy.add({
                  group: "nodes",
                  data: { id: startState.stateNumber.toString(), name: startState.stateNumber.toString(), faveColor: "blue", faveShape: 'ellipse' }
              });
              var stopState=parser._interp.atn.ruleToStopState[rule];
              cy.add({
                  group: "nodes",
                  data: { id: stopState.stateNumber.toString(), name: stopState.stateNumber.toString(), faveColor: "blue", faveShape: 'ellipse' }
              });
              recurseATN(rule, cy, startState, startState.transitions[0], false);
                cy.resize();

var options ={
  name: 'dagre',
// dagre algo options, uses default value on undefined
  nodeSep: undefined, // the separation between adjacent nodes in the same rank
  edgeSep: undefined, // the separation between adjacent edges in the same rank
  rankSep: undefined, // the separation between adjacent nodes in the same rank
  rankDir: 'LR', // 'TB' for top to bottom flow, 'LR' for left to right,
  ranker: undefined, // Type of algorithm to assign a rank to each node in the input graph. Possible values: 'network-simplex', 'tight-tree' or 'longest-path'
  minLen: function( edge ){ return 1; }, // number of ranks to keep between the source and target of the edge
  edgeWeight: function( edge ){ return 1; }, // higher weight edges are generally made shorter and straighter than lower weight edges

  // general layout options
  fit: true, // whether to fit to viewport
  padding: 30, // fit padding
  spacingFactor: undefined, // Applies a multiplicative factor (>0) to expand or compress the overall area that the nodes take up
  nodeDimensionsIncludeLabels: false, // whether labels should be included in determining the space used by a node
  animate: false, // whether to transition the node positions
  animateFilter: function( node, i ){ return true; }, // whether to animate specific nodes when animation is on; non-animated nodes immediately go to their final positions
  animationDuration: 500, // duration of animation in ms if enabled
  animationEasing: undefined, // easing of animation if enabled
  boundingBox: undefined, // constrain layout bounds; { x1, y1, x2, y2 } or { x1, y1, w, h }
  transform: function( node, pos ){ return pos; }, // a function that applies a transform to the final node position
  ready: function(){}, // on layoutready
  stop: function(){} // on layoutstop
  };
var layout = cy.elements().layout( options );
layout.run();
//document.getElementById('canvasEditor').style.display = "none";
//document.getElementById('cursor').style.display = "none";
cy.center();
  }
  
  </script>
</head>
<body>
  <div>
    <div id="info" style="width: 400px; float: left;">
      <input type="file" id="files" name="files[]" multiple />
      <output id="list"></output>
    </div>
  </div>
  <div id="container" width="100%" height="100%" style="clear:both;">
  <div id="plate">
    <canvas id="canvasEditor" width="1200" height="500" tabindex="1"/>
  </div>
    <footer id="foot"></footer>
  </div>

  <script src="js/file-reader-logic.js" type="text/javascript" charset="utf-8"></script>
</body>
</html>